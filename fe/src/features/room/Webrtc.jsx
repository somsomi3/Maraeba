import React, { useEffect, useRef, useState, useCallback } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { useSelector } from "react-redux";
import { springApi } from "../../utils/api.js";
import GoBackButton from "../../components/button/GoBackButton";
import "./Webrtc.css";
import backgroundImage from "../../assets/background/Webrtc_Bg.webp";
// import rtc from '../../assets/images/rtc.png';

const Webrtc = () => {
    // ===================================================
    //                      ÏÉÅÌÉú & Ï∞∏Ï°∞
    // ===================================================
    const [localStream, setLocalStream] = useState(null);
    const peerConnectionRef = useRef(null);
    const localVideoRef = useRef(null);
    const remoteVideoRef = useRef(null);
    const chatBoxRef = useRef(null);
    const webSocketRef = useRef(null);

    const [message, setMessage] = useState("");
    const [messages, setMessages] = useState([]);
    const [isMuted, setIsMuted] = useState(false);
    const [myUsername, setMyUsername] = useState();
    const [otherUsername, setOtherUsername] = useState();

    // ÌÜµÌôî ÏãúÍ∞Ñ Í∏∞Î°ù (Î°úÍ∑∏ Ï†ÄÏû•Ïóê ÌôúÏö©)
    const [startTime, setStartTime] = useState(null);
    const [endTime, setEndTime] = useState(null);

    // Í≤åÏûÑ Í¥ÄÎ†® ÏÉÅÌÉú
    const [isGameStarted, setIsGameStarted] = useState(false);
    const [items, setItems] = useState([]);
    const [choice, setChoice] = useState(null);
    const [correctAnswer, setCorrectAnswer] = useState(null);

    // Î∞©Ïû• Ïó¨Î∂Ä
    const [isHost, setIsHost] = useState(false);

    // Î°úÎî© & ÎÇòÍ∞ê Ïó¨Î∂Ä
    const [loading, setLoading] = useState(false);
    const [didLeave, setDidLeave] = useState(false);

    // Redux & Router
    const token = useSelector((state) => state.auth.token);
    const userId = useSelector((state) => state.auth.userId);
    const { roomId } = useParams();
    const navigate = useNavigate();

    const [isRecording, setIsRecording] = useState(false); // ÎÖπÏùå Ï§ëÏù∏ÏßÄ Ïó¨Î∂Ä
    const [feedbackMessage, setFeedbackMessage] = useState(""); // ÌîºÎìúÎ∞± Î©îÏãúÏßÄ

    // ÏùåÏÑ± ÎÖπÏùåÏùÑ ÌÜµÌïú Îã®Ïñ¥ ÏÑ†ÌÉù(Ï∞∏Í∞ÄÏûê)
    const mediaRecorderRef = useRef(null); // MediaRecorder Ï∞∏Ï°∞
    const audioChunksRef = useRef([]); // ÎÖπÏùåÎêú ÏùåÏÑ± Îç∞Ïù¥ÌÑ∞ Ï°∞Í∞Å

    // ===================================================
    //                  ÏùåÏÑ± ÎÖπÏùå Í∏∞Îä•
    // ===================================================
    // üé§ ÎÖπÏùå ÏãúÏûë
    const startRecording = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: true,
            });
            const mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = (event) => {
                audioChunksRef.current.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunksRef.current, {
                    type: "audio/webm",
                });
                audioChunksRef.current = [];
                await sendAudioToServer(audioBlob); // ÎÖπÏùåÎêú Ïò§ÎîîÏò§Î•º ÏÑúÎ≤ÑÎ°ú Ï†ÑÏÜ°
            };

            mediaRecorderRef.current = mediaRecorder;
            mediaRecorder.start();
            setIsRecording(true);

            // 4Ï¥à ÌõÑ ÏûêÎèô ÎÖπÏùå Ï¢ÖÎ£å
            setTimeout(() => {
                stopRecording();
            }, 4000);
        } catch (error) {
            console.error("ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠ Ïã§Ìå®:", error);
        }
    };

    // üé§ ÎÖπÏùå Ï¢ÖÎ£å
    const stopRecording = () => {
        if (mediaRecorderRef.current) {
            mediaRecorderRef.current.stop();
            setIsRecording(false);
        }
        // üõë ÎÖπÏùå Ïä§Ìä∏Î¶º(ÎßàÏù¥ÌÅ¨) Ìï¥Ï†ú
        if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
            setLocalStream(null);
        }
    };

    // ===================================================
    //          ÎÖπÏùåÎêú ÏùåÏÑ±ÏùÑ Î∞±ÏóîÎìúÎ°ú Ï†ÑÏÜ°
    // ===================================================

    const sendAudioToServer = async (audioBlob) => {
        const formData = new FormData();
        formData.append("audio", audioBlob, "audio.webm");

        try {
            if (!token)
                throw new Error("Access TokenÏù¥ ÏóÜÏäµÎãàÎã§. Î°úÍ∑∏Ïù∏ÌïòÏÑ∏Ïöî.");

            const response = await springApi.post(
                `/rgames/upload-voice/${roomId}`,
                formData,
                {
                    headers: {
                        Authorization: `Bearer ${token}`,
                        "Content-Type": "multipart/form-data",
                    },
                    withCredentials: true,
                }
            );

            if (response.status === 200) {
                const result = response.data;
                console.log("AI Î≥ÄÌôòÎêú Îã®Ïñ¥:", result);

                // üü¢ Î≥ÄÌôòÎêú Îã®Ïñ¥Í∞Ä `items` Î™©Î°ù Ï§ë ÌïòÎÇòÏù∏ÏßÄ ÌôïÏù∏
                if (result && items.includes(result)) {
                    console.log("Ïò¨Î∞îÎ•∏ Îã®Ïñ¥, Î≤ÑÌäº ÏûêÎèô ÏÑ†ÌÉù:", result);

                    // UIÏóêÏÑú Ìï¥Îãπ Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠Ìïú Í≤ÉÏ≤òÎüº Î≥¥Ïù¥Í≤å ÏÑ§Ï†ï
                    setChoice(result);

                    // WebSocketÏùÑ ÌÜµÌï¥ ÏÉÅÎåÄÎ∞©ÏóêÍ≤åÎèÑ ÏÑ†ÌÉù Ï†ïÎ≥¥ Ï†ÑÏÜ°
                    sendChoice(result);
                } else {
                    console.warn("‚ö†Ô∏è Î≥ÄÌôòÎêú Îã®Ïñ¥Í∞Ä Î™©Î°ùÏóê ÏóÜÏäµÎãàÎã§:", result);
                    setFeedbackMessage("‚ùå Ïò¨Î∞îÎ•∏ Îã®Ïñ¥Î•º ÎßêÌï¥Ï£ºÏÑ∏Ïöî.");
                }
            }
        } catch (error) {
            console.error("‚ùå ÏùåÏÑ± Ï†ÑÏÜ° Ïò§Î•ò:", error);
        }
    };

    // ===================================================
    //                 Ï¥àÍ∏∞ Î∞©Ïû• Ïó¨Î∂Ä ÌôïÏù∏
    // ===================================================
    useEffect(() => {
        if (!roomId) {
            console.error("üö® roomIdÍ∞Ä ÏóÜÏäµÎãàÎã§. Î∞©Ïû• Ïó¨Î∂Ä ÌôïÏù∏ Î∂àÍ∞Ä");
            navigate("/room/RoomList");
            return;
        }
        fetchHostStatus(); // ÏÑúÎ≤ÑÏóê Î∞© Ï∞∏Í∞Ä ÏöîÏ≤≠ÌïòÏó¨ Î∞©Ïû• Ïó¨Î∂Ä ÌôïÏù∏
    }, [roomId]);

    const fetchHostStatus = async () => {
        try {
            const response = await springApi.post(`/rooms/valid`, {
                user_id: userId,
                room_id: roomId,
            });

            if (!response || !response.data) {
                throw new Error("üö® ÏÑúÎ≤Ñ ÏùëÎãµÏù¥ ÏóÜÏäµÎãàÎã§.");
            }

            console.log("ÏùëÎãµ: ", response.data);

            if (response.data.user_cnt > 2) {
                console.error("ÏµúÎåÄ Ïù∏Ïõê Ïàò Ï¥àÍ≥º");
                navigate("/room/RoomList");
            }

            const isHostValue = response.data.is_host || false;
            setIsHost(isHostValue);

            //ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ Ï†ÄÏû•
            const responseUsername = response.data.username;
            setMyUsername(responseUsername);

            console.log("üöÄ Î∞©Ïû• Ïó¨Î∂Ä:", isHostValue ? "Î∞©Ïû•" : "Ï∞∏Í∞ÄÏûê");
            console.log("Ïú†Ï†Ä ÏùëÎãµ : ", responseUsername);
        } catch (error) {
            console.error("Î∞©Ïû• Ïó¨Î∂Ä ÌôïÏù∏ Ïã§Ìå®:", error.message);
            navigate("/room/RoomList");
        }
    };

    // ===================================================
    //             WebSocket Ïó∞Í≤∞ & Ï¥àÍ∏∞ ÏÑ§Ï†ï
    // ===================================================
    useEffect(() => {
        if (!token || !roomId) {
            console.error("‚ùå JWT ÌÜ†ÌÅ∞ ÎòêÎäî roomIdÍ∞Ä ÏóÜÏäµÎãàÎã§.");
            return;
        }
        connectWebSocket(token, roomId);

        // ÏÉàÎ°úÍ≥†Ïπ® / Î∏åÎùºÏö∞Ï†Ä Îã´Í∏∞ Ïãú leave Î©îÏãúÏßÄ Ï†ÑÏÜ°
        const handleBeforeUnload = () => {
            if (
                webSocketRef.current &&
                webSocketRef.current.readyState === WebSocket.OPEN
            ) {
                const leaveMessage = {
                    type: "leave",
                    room_id: roomId,
                    user_id: userId,
                };
                webSocketRef.current.send(JSON.stringify(leaveMessage));
                console.log("üöÄ Î∞© Ìá¥Ïû• Î©îÏãúÏßÄ Ï†ÑÏÜ°:", leaveMessage);
            }
        };
        window.addEventListener("beforeunload", handleBeforeUnload);

        return () => {
            window.removeEventListener("beforeunload", handleBeforeUnload);
        };
        // eslint-disable-next-line
    }, [token, roomId]);

    /**
     * WebSocket Ïó∞Í≤∞ ÏÑ§Ï†ï
     */
    const connectWebSocket = (token, roomId) => {
        if (!roomId) {
            console.error("‚ùå Î∞© ID(roomId)Í∞Ä ÏóÜÏäµÎãàÎã§.");
            return;
        }
        // Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú ÏÜåÏºìÏù¥ ÏûàÏúºÎ©¥ Ï§ëÎ≥µ Ïó∞Í≤∞ X
        if (
            webSocketRef.current &&
            webSocketRef.current.readyState === WebSocket.OPEN
        ) {
            console.warn("‚ö†Ô∏è WebSocketÏù¥ Ïù¥ÎØ∏ Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.");
            return;
        }

        // Ïã§Ï†ú ÏÑúÎ≤Ñ Ï£ºÏÜå/Ìè¨Ìä∏Î•º ÎßûÏ∂∞Ï£ºÏÑ∏Ïöî.
        webSocketRef.current = new WebSocket(
            // `wss://i12e104.p.ssafy.io:8081/WebRTC/signaling?token=${token}&roomId=${roomId}`
            `ws://localhost:8081/WebRTC/signaling?token=${token}&roomId=${roomId}`
        );

        // ÏÜåÏºì open
        webSocketRef.current.onopen = () => {
            console.log(`‚úÖ WebSocket Ïó∞Í≤∞Îê® (Î∞© ID: ${roomId})`);
            const joinMessage = {
                type: "join",
                room_id: roomId,
                user_id: userId,
            };
            webSocketRef.current.send(JSON.stringify(joinMessage));
            console.log("üöÄ Î∞© ÏûÖÏû• Î©îÏãúÏßÄ Ï†ÑÏÜ°:", joinMessage);
        };

        // ÏÜåÏºì message
        webSocketRef.current.onmessage = (event) => {
            handleSocketMessage(event);
        };

        // ÏÜåÏºì close
        webSocketRef.current.onclose = () => {
            console.warn("‚ö†Ô∏è WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£åÎê®. 5Ï¥à ÌõÑ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ...");
            setTimeout(() => {
                connectWebSocket(token, roomId);
            }, 5000);
        };
    };

    // ===================================================
    //        Îí§Î°úÍ∞ÄÍ∏∞(ÎùºÏö∞Ìä∏ Ïù¥Îèô) Îì±ÏúºÎ°ú Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä
    //                Ïñ∏ÎßàÏö¥Ìä∏Îê† Îïå cleanup
    // ===================================================
    useEffect(() => {
        return () => {
            // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú
            if (!didLeave) {
                console.log("[cleanup] Îí§Î°úÍ∞ÄÍ∏∞ or ÎùºÏö∞Ìä∏ Ïù¥Îèô -> sendLeave");
                sendLeave({ showAlert: false });
            }
        };
        // eslint-disable-next-line
    }, [didLeave]);

    // ===================================================
    //              WebSocket Î©îÏãúÏßÄ ÏàòÏã† Ï≤òÎ¶¨
    // ===================================================
    const handleSocketMessage = async (event) => {
        let receivedMessage;
        try {
            receivedMessage = JSON.parse(event.data);
        } catch (e) {
            console.error("JSON ÌååÏã± Ïò§Î•ò:", e);
            return;
        }

        const { type } = receivedMessage || {};

        // ping (Ïó∞Í≤∞ Ïú†ÏßÄÎ•º ÏúÑÌïú Í≤É)Ïù¥Î©¥ Î∞îÎ°ú return
        if (type === "ping") {
            console.log("üì° WebSocket Ping ÏàòÏã†");
            return;
        }

        console.log("üì© WebSocket Î©îÏãúÏßÄ ÏàòÏã†:", receivedMessage);

        switch (type) {
            // WebRTC Offer/Answer/Candidate
            case "offer":
                handleOffer(receivedMessage);
                break;
            case "answer":
                handleAnswer(receivedMessage);
                break;
            case "candidate":
                handleCandidate(receivedMessage);
                break;

            // Í≤åÏûÑ Î°úÏßÅ: Îã®Ïñ¥ Î™©Î°ù(items), Ï∞∏Í∞ÄÏûê ÏÑ†ÌÉù(choice), Ï†ïÎãµ(answerChoice)
            case "items":
                handleItems(receivedMessage);
                break;
            case "choice":
                handleChoice(receivedMessage);
                break;
            case "answerChoice":
                handleAnswerChoice(receivedMessage);
                break;

            // Í∑∏ Ïô∏(Ï±ÑÌåÖ Îì±)
            default:
                // Ï±ÑÌåÖ Î©îÏãúÏßÄ Îì±
                setMessages((prev) => [...prev, receivedMessage]);
                break;
        }
    };

    // ===================================================
    //            Ï£ºÍ∏∞Ï†Å ping Î©îÏãúÏßÄ Î≥¥ÎÇ¥Í∏∞
    // ===================================================
    useEffect(() => {
        const sendPing = () => {
            if (
                webSocketRef.current &&
                webSocketRef.current.readyState === WebSocket.OPEN
            ) {
                webSocketRef.current.send(JSON.stringify({ type: "ping" }));
                console.log("üì° Ping Î©îÏãúÏßÄ Ï†ÑÏÜ°");
            }
        };
        const pingInterval = setInterval(sendPing, 10000); // 10Ï¥àÎßàÎã§ Ïã§Ìñâ

        return () => {
            clearInterval(pingInterval);
        };
    }, []);

    // ===================================================
    //      Ï±ÑÌåÖ Î©îÏãúÏßÄÍ∞Ä Ï∂îÍ∞ÄÎê† Îïå ÏûêÎèô Ïä§ÌÅ¨Î°§
    // ===================================================
    useEffect(() => {
        if (chatBoxRef.current) {
            chatBoxRef.current.scrollTop = chatBoxRef.current.scrollHeight;
        }
    }, [messages]);

    // ===================================================
    //            WebRTC (Ïò§ÎîîÏò§/ÎπÑÎîîÏò§) Î°úÏßÅ
    // ===================================================
    const startMedia = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true,
            });
            setLocalStream(stream);
            if (localVideoRef.current) {
                localVideoRef.current.srcObject = stream;
            }
            const now = new Date().toISOString().slice(0, 19);
            setStartTime(now); // ÏãúÏûëÏãúÍ∞Ñ Ï†ÄÏû•
            console.log("ÎØ∏ÎîîÏñ¥ ÏãúÏûë:", now);
        } catch (error) {
            console.error("ÎØ∏ÎîîÏñ¥ Ï†ëÍ∑º Ïã§Ìå®:", error);
        }
    };

    const endMedia = () => {
        if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
            setLocalStream(null);
            if (localVideoRef.current) {
                localVideoRef.current.srcObject = null;
            }
            const now = new Date().toISOString().slice(0, 19);
            setEndTime(now);
            console.log("ÎØ∏ÎîîÏñ¥ Ï¢ÖÎ£å:", now);
            saveWebRTCLog(startTime, now); //Î°úÍ∑∏ Ï†ÄÏû• Ïã§Ìñâ
        }
    };

    const createPeerConnection = () => {
        peerConnectionRef.current = new RTCPeerConnection({
            iceServers: [
                // {
                //     urls: "turn:3.39.252.223:3478?transport=tcp",
                //     username: import.meta.env.VITE_USERNAME_URL,
                //     credential: import.meta.env.VITE_PASSWORD_URL,
                // },
                { urls: "stun:stun.l.google.com:19302" },
            ],
        });

        // ICE Candidate Í∞êÏßÄ
        peerConnectionRef.current.onicecandidate = (event) => {
            if (event.candidate) {
                sendToServer({
                    type: "candidate",
                    candidate: event.candidate,
                    room_id: roomId,
                    user_id: userId,
                });
            }
        };

        // ÏõêÍ≤© Ìä∏Îûô ÏàòÏã†
        peerConnectionRef.current.ontrack = (event) => {
            if (remoteVideoRef.current) {
                remoteVideoRef.current.srcObject = event.streams[0];
            }
        };

        // Î°úÏª¨ Ïä§Ìä∏Î¶º Ìä∏Îûô Ï∂îÍ∞Ä
        if (localStream) {
            localStream.getTracks().forEach((track) => {
                peerConnectionRef.current.addTrack(track, localStream);
            });
        }
    };

    // Offer ÏÉùÏÑ± Î∞è Ï†ÑÏÜ°
    const createOffer = async () => {
        createPeerConnection();
        try {
            const offer = await peerConnectionRef.current.createOffer();
            await peerConnectionRef.current.setLocalDescription(offer);
            sendToServer({
                type: "offer",
                sdp: offer.sdp,
                room_id: roomId,
                user_id: userId,
            });
        } catch (error) {
            console.error("Offer ÏÉùÏÑ± Ïã§Ìå®:", error);
        }
    };

    // Offer ÏàòÏã† Ï≤òÎ¶¨
    const handleOffer = async (message) => {
        createPeerConnection();
        try {
            await peerConnectionRef.current.setRemoteDescription(
                new RTCSessionDescription({
                    type: "offer",
                    sdp: message.sdp,
                })
            );
            const answer = await peerConnectionRef.current.createAnswer();
            await peerConnectionRef.current.setLocalDescription(answer);
            sendToServer({
                type: "answer",
                sdp: answer.sdp,
                room_id: roomId,
                user_id: userId,
            });
        } catch (error) {
            console.error("Offer Ï≤òÎ¶¨ Ïã§Ìå®:", error);
        }
    };

    // Answer ÏàòÏã† Ï≤òÎ¶¨
    const handleAnswer = async (message) => {
        try {
            await peerConnectionRef.current.setRemoteDescription(
                new RTCSessionDescription({
                    type: "answer",
                    sdp: message.sdp,
                })
            );
        } catch (error) {
            console.error("Answer Ï≤òÎ¶¨ Ïã§Ìå®:", error);
        }
    };

    // ICE Candidate Ï≤òÎ¶¨
    const handleCandidate = async (message) => {
        try {
            if (message.candidate) {
                await peerConnectionRef.current.addIceCandidate(
                    new RTCIceCandidate(message.candidate)
                );
            }
        } catch (error) {
            console.error("ICE Candidate Ï∂îÍ∞Ä Ïã§Ìå®:", error);
        }
    };

    // ===================================================
    //              WebSocket Î©îÏãúÏßÄ Ï†ÑÏÜ° Í≥µÌÜµ
    // ===================================================
    const sendToServer = (msgObj) => {
        if (!roomId) {
            console.error("roomIdÍ∞Ä ÏóÜÏäµÎãàÎã§. Î©îÏãúÏßÄÎ•º Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }

        if (
            webSocketRef.current &&
            webSocketRef.current.readyState === WebSocket.OPEN
        ) {
            webSocketRef.current.send(JSON.stringify(msgObj));
        } else {
            console.error("‚ùå WebSocketÏù¥ Îã´ÌòÄ ÏûàÏñ¥ Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:", msgObj);
        }
    };

    // ===================================================
    //                   Ï±ÑÌåÖ Î°úÏßÅ
    // ===================================================
    const sendMessage = () => {
        if (!message.trim()) {
            console.error("‚ùå Î©îÏãúÏßÄÍ∞Ä ÎπÑÏñ¥ ÏûàÏùå");
            return;
        }
        if (!myUsername) {
            console.error("‚ùå ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ ÏóÜÏùå! (ÏïÑÏßÅ Î°úÎî© Ï§ëÏùº Í∞ÄÎä•ÏÑ± ÏûàÏùå)");
            return;
        }
        if (
            !webSocketRef.current ||
            webSocketRef.current.readyState !== WebSocket.OPEN
        ) {
            console.error("‚ùå WebSocket Ïó∞Í≤∞Ïù¥ Îã´ÌòÄ ÏûàÏùå");
            return;
        }

        if (!userId) {
            console.error("ÏÇ¨Ïö©Ïûê ID ÏóÜÏùå");
            return;
        }
        if (!myUsername) {
            console.error("ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ ÏóÜÏùå!");
            return;
        }
        const messageObject = {
            type: "chat",
            user_id: userId,
            username: myUsername,
            message: message.trim(),
            room_id: roomId,
            sentAt: new Date().toISOString(),
        };
        console.log("üì° Ï±ÑÌåÖ Î©îÏãúÏßÄ Ï†ÑÏÜ°:", messageObject);

        webSocketRef.current.send(JSON.stringify(messageObject));

        // UIÏóê Ï±ÑÌåÖ Ï∂îÍ∞Ä
        setMessages((prev) => [...prev, messageObject]);
        setMessage("");

        // (ÏÑ†ÌÉù) DBÏóê Ï†ÄÏû•
        saveMessageToDB(messageObject);
    };

    const saveMessageToDB = async (messageObject) => {
        const requestPayload = {
            message: messageObject.message,
            room_id: messageObject.room_id,
            sent_at: messageObject.sentAt,
            user_id: messageObject.user_id,
        };

        if (!requestPayload.user_id) {
            console.error("‚ùå user_idÍ∞Ä ÏóÜÏñ¥ Î©îÏãúÏßÄ DB Ï†ÄÏû• Î∂àÍ∞Ä");
            return;
        }

        try {
            const response = await springApi.post(
                "/webrtcs/message",
                requestPayload
            );
            console.log("‚úÖ Î©îÏãúÏßÄ Ï†ÄÏû• ÏÑ±Í≥µ:", response.data);
        } catch (error) {
            console.error("Î©îÏãúÏßÄ Ï†ÄÏû• Ïã§Ìå®:", error);
        }
    };

    // ===================================================
    //              ÏùåÏÜåÍ±∞ ÌÜ†Í∏Ä
    // ===================================================
    const toggleMute = () => {
        if (localStream) {
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                setIsMuted(!isMuted);
            }
        }
    };

    // ===================================================
    //        ‚ÄúÎÇòÍ∞ÄÍ∏∞‚Äù (ÏàòÎèô + Îí§Î°úÍ∞ÄÍ∏∞ cleanup)
    // ===================================================
    const sendLeave = useCallback(
        (options = { showAlert: true }) => {
            // Ïù¥ÎØ∏ Îñ†ÎÇ¨ÏúºÎ©¥ Ï§ëÎ≥µ X
            if (didLeave) return;
            setDidLeave(true);

            if (options.showAlert) {
                alert("Î∞©ÏóêÏÑú ÎÇòÍ∞ëÎãàÎã§.");
            }

            if (
                webSocketRef.current &&
                webSocketRef.current.readyState === WebSocket.OPEN
            ) {
                const messageObject = {
                    type: "leave",
                    user_id: userId,
                    room_id: roomId,
                    sentAt: new Date().toISOString(),
                };
                console.log("üì° Î∞© Ìá¥Ïû• Î©îÏãúÏßÄ Ï†ÑÏÜ°:", messageObject);
                webSocketRef.current.send(JSON.stringify(messageObject));
            }

            if (webSocketRef.current) {
                webSocketRef.current.close();
            }

            // üõë ÎßàÏù¥ÌÅ¨ & Ïπ¥Î©îÎùº Ïä§Ìä∏Î¶º Ï¢ÖÎ£å
            if (localStream) {
                localStream.getTracks().forEach((track) => track.stop());
                setLocalStream(null);
            }
            // üõë WebRTC PeerConnection Îã´Í∏∞
            if (peerConnectionRef.current) {
                peerConnectionRef.current.close();
                peerConnectionRef.current = null;
            }
            // üõë MediaRecorder Ï†ïÎ¶¨
            if (mediaRecorderRef.current) {
                mediaRecorderRef.current.stop();
                mediaRecorderRef.current = null;
            }

            navigate("/room/RoomList");
        },
        [didLeave, userId, roomId, navigate, localStream]
    );

    // ===================================================
    //           WebRTC ÏÇ¨Ïö© Î°úÍ∑∏ ÏÑúÎ≤Ñ Ï†ÑÏÜ°
    // ===================================================
    const saveWebRTCLog = async (start, end) => {
        if (!userId) {
            console.error("ÏÇ¨Ïö©Ïûê ID ÏóÜÏùå! Î°úÍ∑∏ Ï†ÄÏû• Î∂àÍ∞Ä.");
            return;
        }

        const logData = {
            room_id: roomId,
            user_id: userId,
            start_time: start,
            end_time: end,
        };
        console.log("üìÑ WebRTC Î°úÍ∑∏ Ï†ÑÏÜ°:", logData);

        try {
            const response = await springApi.post("/webrtcs/log", logData, {
                headers: {
                    Authorization: "Bearer " + localStorage.getItem("token"),
                },
            });

            if (response.status === 200) {
                console.log("WebRTC Î°úÍ∑∏ Ï†ÄÏû• ÏÑ±Í≥µ");
            } else {
                console.error("WebRTC Î°úÍ∑∏ Ï†ÄÏû• Ïã§Ìå®");
            }
        } catch (error) {
            console.error("Î°úÍ∑∏ Ï†ÄÏû• Ï§ë Ïò§Î•ò:", error);
        }
    };

    // ===================================================
    //               Í≤åÏûÑ Í¥ÄÎ†® (items, choice)
    // ===================================================
    /**
     * Î∞©Ïû•Ïù¥ "Í≤åÏûÑ ÏãúÏûë" Î≤ÑÌäº ÌÅ¥Î¶≠
     * - ÏûÑÏãúÎ°ú springApi Ìò∏Ï∂ú ÌõÑ, items Î°úÎìú
     */
    const startGame = async () => {
        if (!isHost) {
            alert("Î∞©Ïû•Îßå Í≤åÏûÑÏùÑ ÏãúÏûëÌï† Ïàò ÏûàÏäµÎãàÎã§.");
            return;
        }
        try {
            const response = await springApi.post(`/rgames/start/${roomId}`, {
                userId,
            });
            if (response.status === 200) {
                setIsGameStarted(true);
            }
            setChoice(null);
            setCorrectAnswer(null);
            fetchGameWords();
        } catch (error) {
            console.error("Í≤åÏûÑ ÏãúÏûë Ïò§Î•ò:", error);
        }
    };

    // Îã®Ïñ¥ Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞
    const fetchGameWords = async () => {
        try {
            const response = await springApi.get(`/rgames/item`);
            console.log("üì© Í≤åÏûÑ Îã®Ïñ¥ Î™©Î°ù ÏùëÎãµ:", response.data);

            if (response.status === 200 && typeof response.data === "object") {
                const wordsArray = Object.values(response.data);
                setItems(wordsArray);
            } else {
                console.error("üö® ÏÑúÎ≤Ñ ÏùëÎãµÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏùå:", response.data);
                setItems([]);
            }
        } catch (error) {
            console.error("Îã®Ïñ¥ Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", error);
            setItems([]);
        }
    };

    // Îã®Ïñ¥ Î™©Î°ù ÏàòÏã† (WebSocket)
    const handleItems = (message) => {
        const received = message.items;
        if (Array.isArray(received)) {
            setChoice(null);
            setCorrectAnswer(null);
            setItems(received);
            console.log("üìù ÏàòÏã†Ìïú items:", received);
            setIsGameStarted(true);
        } else {
            console.error("üö® items Îç∞Ïù¥ÌÑ∞Í∞Ä Î∞∞Ïó¥Ïù¥ ÏïÑÎãò:", received);
        }
    };

    // ÏÑ†ÌÉù(choice) ÏàòÏã† (Ï∞∏Í∞ÄÏûê)
    const handleChoice = (message) => {
        if (message.choice) {
            setChoice(message.choice);
            console.log("üìù Ï∞∏Í∞ÄÏûê choice ÏàòÏã†:", message.choice);
        } else {
            console.error("üö® ÏûòÎ™ªÎêú choice Îç∞Ïù¥ÌÑ∞:", message);
        }
    };

    // Ï†ïÎãµ(answerChoice) ÏàòÏã†
    const handleAnswerChoice = (message) => {
        if (message.answer_choice) {
            setCorrectAnswer(message.answer_choice);
            console.log("üìù Ï†ïÎãµ(answerChoice) ÏàòÏã†:", message.answer_choice);
        } else {
            console.error("üö® ÏûòÎ™ªÎêú answerChoice Îç∞Ïù¥ÌÑ∞:", message);
        }
    };

    // Ìò∏Ïä§Ìä∏Í∞Ä Îã®Ïñ¥ Î™©Î°ù(items)ÏùÑ Î™®ÎëêÏóêÍ≤å Ï†ÑÏÜ°
    const sendItems = () => {
        if (!isHost || !items.length) return;
        if (
            webSocketRef.current &&
            webSocketRef.current.readyState === WebSocket.OPEN
        ) {
            const msg = {
                type: "items",
                user_id: userId,
                items,
                room_id: roomId,
                sentAt: new Date().toISOString(),
            };
            console.log("üì° items Ï†ÑÏÜ°:", msg);
            webSocketRef.current.send(JSON.stringify(msg));
        }
    };

    // Ï∞∏Í∞ÄÏûê: Îã®Ïñ¥Î•º Í≥®ÎûêÏùÑ Îïå
    const sendChoice = (word) => {
        setChoice(word);
        if (!word) {
            console.error("üö® `sendChoice()` Ìò∏Ï∂ú Ïãú wordÍ∞Ä undefinedÏûÖÎãàÎã§!");
            return;
        }

        if (!isHost) {
            if (
                webSocketRef.current &&
                webSocketRef.current.readyState === WebSocket.OPEN
            ) {
                const msg = {
                    type: "choice",
                    user_id: userId,
                    choice: word,
                    room_id: roomId,
                    sentAt: new Date().toISOString(),
                };
                console.log("üì° choice Ï†ÑÏÜ°:", msg);
                webSocketRef.current.send(JSON.stringify(msg));
            }
        }
    };

    // Ìò∏Ïä§Ìä∏: Ï†ïÎãµ(answerChoice)Î•º ÏÑ†ÌÉùÌñàÏùÑ Îïå
    const sendAnswerChoice = (answerChoice) => {
        setCorrectAnswer(answerChoice);
        if (!isHost) {
            console.error("‚ùå Ï∞∏Í∞ÄÏûêÎäî answerChoiceÎ•º Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.");
            return;
        }
        if (
            webSocketRef.current &&
            webSocketRef.current.readyState === WebSocket.OPEN
        ) {
            const msg = {
                type: "answerChoice",
                user_id: userId,
                answer_choice: answerChoice,
                room_id: roomId,
                sentAt: new Date().toISOString(),
            };
            console.log("üì° answerChoice Ï†ÑÏÜ°:", msg);
            webSocketRef.current.send(JSON.stringify(msg));
        }
    };

    /**
     * itemsÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§
     * - Î∞©Ïû•Ïù¥Î©¥ Îã§Î•∏ Ï∞∏Í∞ÄÏûêÏóêÍ≤åÎèÑ Ï†ÑÏÜ°
     */
    useEffect(() => {
        if (isHost && items.length > 0) {
            sendItems();
        }
    }, [items]); // items Î≥ÄÍ≤Ω Í∞êÏßÄ

    // ===================================================
    //                      Î†åÎçîÎßÅ
    // ===================================================
    return (
        <div
            className="webrtc-container"
            style={{ backgroundImage: `url(${backgroundImage})` }}
        >
            <div className="webrtc-game-overlay">
                {/* ÏôºÏ™Ω - ÏÉÅÎåÄÎ∞©(ÌÅ∞ ÌôîÎ©¥) + ÎÇ¥ ÌôîÎ©¥(ÏûëÏùÄ ÌôîÎ©¥) */}
                <GoBackButton />
                {/* ‚úÖ ÎπÑÎîîÏò§ Ïª®ÌÖåÏù¥ÎÑà + Ï±ÑÌåÖ Ïª®ÌÖåÏù¥ÎÑàÎ•º Í∞ÄÎ°ú Ï†ïÎ†¨ */}
                <div className="video-chat-wrapper">
                    <div className="video-answer-wrapper">
                        {/* Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäº (Î∞©Ïû•Îßå Î≥¥Ïù¥ÎèÑÎ°ù ÏÑ§Ï†ï) */}
                        {isHost && (
                            <button
                                onClick={() => {
                                    console.log("üéÆ Í≤åÏûÑ ÏãúÏûë Î≤ÑÌäº ÌÅ¥Î¶≠Îê®!"); // üî• ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä
                                    startGame(); // ‚úÖ Îã®Ïñ¥ Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìñâ
                                }}
                                className="start-game-button"
                            >
                                Í≤åÏûÑ ÏãúÏûë
                            </button>
                        )}
                    </div>

                    <div className="video-container">
                        <div className="video-wrapper">
                            {/* ÏÉÅÎåÄÎ∞© ÌôîÎ©¥ */}
                            <div className="video-box">
                                <div className="video-label">ÏÉÅÎåÄÎ∞© ÌôîÎ©¥</div>
                                <video
                                    ref={remoteVideoRef}
                                    autoPlay
                                    playsInline
                                    className="large-video"
                                    aria-label="ÏÉÅÎåÄÎ∞© ÎπÑÎîîÏò§"
                                />
                            </div>

                            {/* Î≥∏Ïù∏ ÌôîÎ©¥ */}
                            <div className="video-box small-video-container">
                                <div className="video-label">Î≥∏Ïù∏ ÌôîÎ©¥</div>
                                <div className="role-badge">
                                    {isHost ? "üëë" : "üéÑ"}
                                </div>
                                <video
                                    ref={localVideoRef}
                                    autoPlay
                                    playsInline
                                    muted
                                    className="small-video"
                                    aria-label="ÎÇ¥ ÎπÑÎîîÏò§"
                                />
                            </div>
                        </div>

                        <div className="button-container">
                            <button onClick={startMedia} className="button">
                                üé• ÎÇòÏùò ÌôîÎ©¥ Ïó¥Í∏∞
                            </button>
                            <button onClick={createOffer} className="button">
                                üì° ÎÇòÏùò ÌôîÎ©¥ Î≥¥Ïó¨Ï£ºÍ∏∞
                            </button>
                            <button onClick={endMedia} className="button">
                                üõë Ï¢ÖÎ£å
                            </button>
                            <button onClick={toggleMute} className="button">
                                {isMuted ? "üîá ÏùåÏÜåÍ±∞ Ìï¥Ï†ú" : "üé§ ÏùåÏÜåÍ±∞"}
                            </button>
                        </div>
                    </div>

                    {/* Ï±ÑÌåÖ Ïª®ÌÖåÏù¥ÎÑà */}
                    <div className="chat-container" role="region">
                        <div ref={chatBoxRef} className="chat-box">
                            {messages.map((msg, idx) => (
                                <div
                                    key={idx}
                                    className={
                                        msg.username === myUsername
                                            ? "my-message"
                                            : "other-message"
                                    }
                                >
                                    <strong>{msg.username}: </strong>
                                    {msg.message}
                                </div>
                            ))}
                        </div>

                        {/* ÏûÖÎ†•Ï∞Ω */}
                        <div className="input-container">
                            <input
                                type="text"
                                value={message}
                                onChange={(e) => setMessage(e.target.value)}
                                onKeyDown={(e) => {
                                    if (e.key === "Enter") {
                                        e.preventDefault(); // Ìèº ÏûêÎèô Ï†úÏ∂ú Î∞©ÏßÄ
                                        sendMessage();
                                    }
                                }}
                                placeholder="Î©îÏãúÏßÄ ÏûÖÎ†•..."
                                className="input"
                            />
                            <button
                                onClick={sendMessage}
                                className="send-button"
                            >
                                Ï†ÑÏÜ°
                            </button>
                        </div>
                    </div>
                </div>

                {/* Ïò§Î•∏Ï™Ω - Í≤åÏûÑ UI */}
                <div className="webrtc-game-container">
                    <h2>üéÆ ÏÇ¨Î¨º ÎßûÏ∂îÍ∏∞ Í≤åÏûÑ</h2>
                    <div
                        style={{
                            display: "inline-flex",
                            alignItems: "center", // Î¨∏Íµ¨ÏôÄ Î≤ÑÌäº ÏàòÏßÅ Ï†ïÎ†¨
                            gap: "1rem", // Î¨∏Íµ¨ÏôÄ Î≤ÑÌäº ÏÇ¨Ïù¥ Í∞ÑÍ≤©
                        }}
                    >
                        <p style={{ margin: 0 }}>
                            ÏûÖÎ™®ÏñëÏùÑ Î≥¥Í≥†, ÏÉâÏÉÅÏù¥ Îì§Ïñ¥Í∞Ñ Ï†ïÎãµÏùÑ ÎßêÌïòÏÑ∏Ïöî!
                        </p>
                        {/* ÎßêÌïòÍ∏∞/Í∑∏ÎßåÌïòÍ∏∞ Î≤ÑÌäº */}
                        {!isHost && (
                            <button
                                className={`voice-record-button ${
                                    isRecording ? "recording" : ""
                                }`}
                                onClick={
                                    isRecording ? stopRecording : startRecording
                                }
                            >
                                {isRecording ? "Í∑∏ÎßåÌïòÍ∏∞" : "ÎßêÌïòÍ∏∞"}
                            </button>
                        )}
                    </div>
                    {/* üõ†Ô∏è Î°úÍ∑∏ Ï∂îÍ∞Ä: items ÏÉÅÌÉú ÌôïÏù∏ */}
                    {console.log("üìå Î†åÎçîÎßÅ Ï§ë items ÏÉÅÌÉú:", items)}

                    <div className="game-buttons">
                        {items.length > 0 ? (
                            items.map((word, index) => (
                                <button
                                    key={index}
                                    onClick={() => {
                                        if (isHost) {
                                            sendAnswerChoice(word); // Î∞©Ïû•ÏùÄ Ï†ïÎãµÏùÑ ÏÑ†ÌÉùÌïòÎ©¥ Ï∞∏Í∞ÄÏûêÏóêÍ≤å Ï†ÑÏÜ°Îê®
                                        } else {
                                            setChoice(word); // Ï∞∏Í∞ÄÏûêÎäî ÌÅ¥Î¶≠ Ïãú UIÏóêÎßå Î∞òÏòÅ (Î∞©Ïû•ÏóêÍ≤å Ï†ÑÏÜ° X)
                                        }
                                    }}
                                    onDoubleClick={() =>
                                        !isHost && sendChoice(word)
                                    } // Ï∞∏Í∞ÄÏûêÍ∞Ä ÏùåÏÑ±ÏúºÎ°ú ÏÑ†ÌÉùÌïú Í≤ΩÏö∞Îßå Î∞©Ïû•ÏóêÍ≤å Ï†ÑÏÜ°
                                    className={`game-button 
                    ${choice === word ? "selected" : ""} 
                    ${correctAnswer === word ? "correct" : ""}`} // Ï†ïÎãµ(Î∞©Ïû•Ïù¥ ÏÑ†ÌÉùÌïú Í≤É)ÏùÄ Ï∞∏Í∞ÄÏûêÏóêÍ≤å Í∞ïÏ°∞
                                    aria-label={`Í≤åÏûÑ Î≤ÑÌäº: ${word}`}
                                >
                                    {word}
                                </button>
                            ))
                        ) : (
                            <p className="loading-message">
                                üìå Îã®Ïñ¥ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...
                            </p>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default Webrtc;
